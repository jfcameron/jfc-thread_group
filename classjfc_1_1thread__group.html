<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>jfc-thread_group: jfc::thread_group Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">jfc-thread_group
   &#160;<span id="projectnumber">1d56be107c82a433e6cc1fce510f0242b7ac86eb</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>jfc</b></li><li class="navelem"><a class="el" href="classjfc_1_1thread__group.html">thread_group</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classjfc_1_1thread__group-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">jfc::thread_group Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>task-based concurrency abstraction. instantiates a number of threads at construction, provides tasks for them to execute via a synchronized queue.  
 <a href="classjfc_1_1thread__group.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="thread__group_8h_source.html">thread_group.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1cf5ba4d974aa1d8a51137b22bb5272c"><td class="memItemLeft" align="right" valign="top"><a id="a1cf5ba4d974aa1d8a51137b22bb5272c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjfc_1_1thread__group.html#a1cf5ba4d974aa1d8a51137b22bb5272c">task_type</a> = std::function&lt; void()&gt;</td></tr>
<tr class="memdesc:a1cf5ba4d974aa1d8a51137b22bb5272c"><td class="mdescLeft">&#160;</td><td class="mdescRight">alias for task functor <br /></td></tr>
<tr class="separator:a1cf5ba4d974aa1d8a51137b22bb5272c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea2d04f92d6b96a0855215a2d34e0d0"><td class="memItemLeft" align="right" valign="top"><a id="a8ea2d04f92d6b96a0855215a2d34e0d0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjfc_1_1thread__group.html#a8ea2d04f92d6b96a0855215a2d34e0d0">thread_collection_type</a> = std::vector&lt; std::thread &gt;</td></tr>
<tr class="memdesc:a8ea2d04f92d6b96a0855215a2d34e0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">alias for thread collection <br /></td></tr>
<tr class="separator:a8ea2d04f92d6b96a0855215a2d34e0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3687461368df19724ba5ac70f8145f9"><td class="memItemLeft" align="right" valign="top"><a id="ac3687461368df19724ba5ac70f8145f9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjfc_1_1thread__group.html#ac3687461368df19724ba5ac70f8145f9">thread_id_collection_type</a> = std::vector&lt; std::thread::id &gt;</td></tr>
<tr class="memdesc:ac3687461368df19724ba5ac70f8145f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">alias for thread id collection <br /></td></tr>
<tr class="separator:ac3687461368df19724ba5ac70f8145f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abf1d37a35a70e40b9aedc3b3c89ee77b"><td class="memItemLeft" align="right" valign="top"><a id="abf1d37a35a70e40b9aedc3b3c89ee77b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjfc_1_1thread__group.html#abf1d37a35a70e40b9aedc3b3c89ee77b">thread_count</a> () const</td></tr>
<tr class="memdesc:abf1d37a35a70e40b9aedc3b3c89ee77b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the number of threads in the group <br /></td></tr>
<tr class="separator:abf1d37a35a70e40b9aedc3b3c89ee77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c7c34a25d3b9fe4e944f968e245c53"><td class="memItemLeft" align="right" valign="top"><a id="af8c7c34a25d3b9fe4e944f968e245c53"></a>
<a class="el" href="classjfc_1_1thread__group.html#ac3687461368df19724ba5ac70f8145f9">thread_id_collection_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjfc_1_1thread__group.html#af8c7c34a25d3b9fe4e944f968e245c53">thread_ids</a> () const</td></tr>
<tr class="memdesc:af8c7c34a25d3b9fe4e944f968e245c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">brief returns a collection of IDs for the threads in the group <br /></td></tr>
<tr class="separator:af8c7c34a25d3b9fe4e944f968e245c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9632a85beb7eef4a68aab3879ca473"><td class="memItemLeft" align="right" valign="top"><a id="a8b9632a85beb7eef4a68aab3879ca473"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjfc_1_1thread__group.html#a8b9632a85beb7eef4a68aab3879ca473">add_tasks</a> (std::vector&lt; <a class="el" href="classjfc_1_1thread__group.html#a1cf5ba4d974aa1d8a51137b22bb5272c">task_type</a> &gt; &amp;&amp;tasks)</td></tr>
<tr class="memdesc:a8b9632a85beb7eef4a68aab3879ca473"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a collection of tasks to the task collection <br /></td></tr>
<tr class="separator:a8b9632a85beb7eef4a68aab3879ca473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4f25f528258ea2f50e7e3cc0d81e09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjfc_1_1thread__group.html#a9f4f25f528258ea2f50e7e3cc0d81e09">add_tasks</a> (<a class="el" href="classjfc_1_1thread__group.html#a1cf5ba4d974aa1d8a51137b22bb5272c">task_type</a> &amp;&amp;task)</td></tr>
<tr class="separator:a9f4f25f528258ea2f50e7e3cc0d81e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08d65909b4ab55bb4af8deec0e395f2"><td class="memItemLeft" align="right" valign="top"><a id="af08d65909b4ab55bb4af8deec0e395f2"></a>
std::optional&lt; <a class="el" href="classjfc_1_1thread__group.html#a1cf5ba4d974aa1d8a51137b22bb5272c">task_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjfc_1_1thread__group.html#af08d65909b4ab55bb4af8deec0e395f2">try_get_task</a> ()</td></tr>
<tr class="memdesc:af08d65909b4ab55bb4af8deec0e395f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes and returns a task if the task collection is nonzero. this can be called publicly to allow threads outside the threadgroup to help perform its tasks (typically the thread which created the group in the first place) <br /></td></tr>
<tr class="separator:af08d65909b4ab55bb4af8deec0e395f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d918f95a874b9c1cce098b63fd6b058"><td class="memItemLeft" align="right" valign="top"><a id="a9d918f95a874b9c1cce098b63fd6b058"></a>
<a class="el" href="classjfc_1_1thread__group.html">thread_group</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjfc_1_1thread__group.html#a9d918f95a874b9c1cce098b63fd6b058">operator=</a> (<a class="el" href="classjfc_1_1thread__group.html">thread_group</a> &amp;&amp;b)</td></tr>
<tr class="memdesc:a9d918f95a874b9c1cce098b63fd6b058"><td class="mdescLeft">&#160;</td><td class="mdescRight">supports move semantics <br /></td></tr>
<tr class="separator:a9d918f95a874b9c1cce098b63fd6b058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26cc6b24ce10453f55b3b9e31749fdfb"><td class="memItemLeft" align="right" valign="top"><a id="a26cc6b24ce10453f55b3b9e31749fdfb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjfc_1_1thread__group.html#a26cc6b24ce10453f55b3b9e31749fdfb">thread_group</a> (<a class="el" href="classjfc_1_1thread__group.html">thread_group</a> &amp;&amp;b)</td></tr>
<tr class="memdesc:a26cc6b24ce10453f55b3b9e31749fdfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">supports move semantics <br /></td></tr>
<tr class="separator:a26cc6b24ce10453f55b3b9e31749fdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86cda0f3faa3167016e9938a56fea4b3"><td class="memItemLeft" align="right" valign="top"><a id="a86cda0f3faa3167016e9938a56fea4b3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjfc_1_1thread__group.html#a86cda0f3faa3167016e9938a56fea4b3">thread_group</a> (size_t threadNumber)</td></tr>
<tr class="memdesc:a86cda0f3faa3167016e9938a56fea4b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a threadgroup with the specified number of threads. <br /></td></tr>
<tr class="separator:a86cda0f3faa3167016e9938a56fea4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7951318f577b9e7527ee51d4fb5d1d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjfc_1_1thread__group.html#af7951318f577b9e7527ee51d4fb5d1d5">thread_group</a> ()</td></tr>
<tr class="memdesc:af7951318f577b9e7527ee51d4fb5d1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct a thread group of size std::thread::hardware_concurrency() -1  <a href="#af7951318f577b9e7527ee51d4fb5d1d5">More...</a><br /></td></tr>
<tr class="separator:af7951318f577b9e7527ee51d4fb5d1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>task-based concurrency abstraction. instantiates a number of threads at construction, provides tasks for them to execute via a synchronized queue. </p>
<dl class="section remark"><dt>Remarks</dt><dd>all methods are thread friendly </dd>
<dd>
all const methods are synchronization free </dd>
<dd>
all mutable methods incur synchronization costs via atomic operations </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af7951318f577b9e7527ee51d4fb5d1d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7951318f577b9e7527ee51d4fb5d1d5">&#9670;&nbsp;</a></span>thread_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">jfc::thread_group::thread_group </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construct a thread group of size std::thread::hardware_concurrency() -1 </p>
<p>hardware_concurrency is a hint provided by the implementation about the # of threads that can be executed simultaneously on the hardware. The significance of a group of this size is that it represents a group that should be able to truly run concurrently on the system. The -1 refers to the thread responsible for creating the group, which cannot be captured by the group ctor, since that thread preceeds construction of the group. If you want the creating thread (-1) to participate in the execution of the <a class="el" href="classjfc_1_1thread__group.html" title="task-based concurrency abstraction. instantiates a number of threads at construction, provides tasks for them to execute via a synchronized queue. ">thread_group</a>'s tasks, call the method "try_get_task" where/whenever appropriate. for example, if blocking this thread is acceptable then you could call it in a loop directly after constructing the group and adding a collection of tasks to it.</p>
<dl class="section warning"><dt>Warning</dt><dd>when calling this ctor, it is possible for the resulting group to contain no threads. This will happen if your platform does not support multithreading. In this case tasks can only be done via try_get_task. This can be checked via the method thread_count or the STL function thread::hardware_concurrency </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9f4f25f528258ea2f50e7e3cc0d81e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4f25f528258ea2f50e7e3cc0d81e09">&#9670;&nbsp;</a></span>add_tasks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jfc::thread_group::add_tasks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classjfc_1_1thread__group.html#a1cf5ba4d974aa1d8a51137b22bb5272c">task_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/travis/build/jfcameron/jfc-thread_group/include/jfc/<a class="el" href="thread__group_8h_source.html">thread_group.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
